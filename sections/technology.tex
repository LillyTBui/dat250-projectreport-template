\section{Technology Assessment}\label{sec:technology}In this section, the feature technology of the project will be presented and compared to another technology in the context of caching.As mentioned in the introduction, the chosen feature technology is Neo4j which will replace Redis.These technologies are different types of NoSQL databases which are optimized for certain use cases.Redis is a hybrid database and caching system which stores data as key-value pairs in-memory.This makes it a common choice for caching.On the other hand, Neo4j is a graph-based database which stores data in nodes and relationships.Therefore, this paper will explore and compare their capabilities in terms of caching ability by following the evaluation framework from \cite{brown:96}, see Figure~\ref{fig:framework}.\begin{figure}[thb]    \centering    \includegraphics[scale=0.6]{figs/framework.png}    \caption{Software technology evaluation framework.}    \label{fig:framework}\end{figure}\subsection{Descriptive Modeling}To get a better understanding of Neo4j and Redis,their genealogy is illustrated in Figure~\ref{fig:genealogy}.The genealogy shows that Neo4j and Redis are different types of NoSQL databases.In particular, Neo4j is a graph database where entities are represented as nodes,and relationships between entities are represented as edges.Graph databases have existed for a long time, but have not been commercially used until the mid-to-late 2000s \cite{graphDB}.During this time the first version of Neo4j was released in February 2010 and has since been gaining popularity \cite{neo4jWiki}.As of November 2025, Neo4j is the most popular graph database according to DB-Engines \cite{graphDBRank}.Similar to other types of graph databases, Neo4j uses its own query language called Cypher.Cypher constructs are declarative, and have similar clauses found in SQL \cite{cypherNeo4j}.The advantage of using graph databases is clear when it comes to storing complex relationships,as these actions can be handled directly.\\\begin{figure}[H]    \centering    \includegraphics[scale=0.5]{figs/genealogy.png}    \caption{Neo4j/Redis genealogy.}    \label{fig:genealogy}\end{figure}Additionally, looking up relationships can be computationally expensive in certain scenarios \cite{Neo4j}.This is because the join queries in relational databases can grow complex and nested as the relationships get advanced.Thus, storing data relationships directly is beneficial in scenarios such as network management system,recommendation system and fraud detection.In those scenarios, having a quick and efficient traversal between data relationships is beneficial.Hence, graph databases are ideal for projects focused on the relationship between data rather than the data itself \cite{Neo4jGettingStarted}.Since graph databases do not use a predefined schema, they are highly flexible.Other graph based databases which share similar functionalities as Neo4j are shown as “peers” in Figure~\ref{fig:genealogy}.\\On the other hand, Redis is both a NoSQL database and a hybrid/cache database which makes it suitable for a variety of different use cases.For instance, the most common use case of Redis is to use it as a cache.However, it is possible to use Redis for durable storage \cite{RedisP}.Redis was created in 2009 and the motivation was to fix the poor scalability in the founder’s startup.Redis has seen massive growth since its release, achieving their record growth in 2025 \cite{RedisWiki}.Similarly to its “peers”, Memcached, Riak and Etcd, Redis stores data as key-value pairs.\\An alternative way of showcasing the use cases and competitors of Redis and Neo4j, is the problem domain habitat in Figure~\ref{fig:habitat}.\begin{figure}[thb]    \centering    \includegraphics[scale=0.5]{figs/habitat.png}    \caption{Elements of the Neo4j/Redis habitat.}    \label{fig:habitat}\end{figure}This figure illustrates the technologies, their respective competitors and the problem context.A problem context is a class of problems addressed by the technology \cite{brown:96}.Whilst, the special characteristic represents the technology’s ability to solve the problem context.\subsection{Experiment Design}In this section, we will plan how we will evaluate and compare the technologies,where the overall goal is to evaluate how different choices of technology can affect the caching ability.The purpose of caching is to improve performance by storing data in a temporary storage,effectively reducing the need for retrieving data from a permanent database \cite{awsCache}.Therefore, it is particularly interesting to compare two NoSQL databases as they have different ways of storing data due to their underlying architecture and structure.\\In order to effectively evaluate these technologies in the predefined context,the following hypotheses have been made:\begin{enumerate}    \item As Redis stores data through key-value pairs and Neo4j stores data in graphs, Redis is faster in terms of adding and retrieving data.\end{enumerate}Based on the results of the mentioned hypotheses above, the last hypothesis is:\begin{enumerate}    \item[2.] In terms of usability and complexity, Redis is simpler to implement than Neo4j.\end{enumerate}The paper tries to answer these hypotheses by conducting an experiment which is a simplified version of the final project.In order to do so, a branch was made for each technology based on the main branch.Then each technology was implemented in a way that serves as a caching service for the main application.This is to get a better understanding of its overall fit with the existing technology stack.\\The experiment can be divided into two parts.First, simulated users will vote on a specific poll where each vote will be stored according to the chosen technology.Then, handlers will retrieve all votes which triggers the caching logic.In this part of the experiment, we can verify that the correct number of votes are saved to the cache.Furthermore, we can confirm that the data is retrieved from the cache and not the permanent database in the correct setting.\\To ensure consistency in both parts of the experiment, it was decided to use JMeter as the tool to perform a load test.This experiment would help refute or support the proposed hypotheses.Since the first hypothesis is related to data retrieval, the total number of simulated users is 1000.It is important to note that this single experiment will address all of the hypotheses, as the setup and experiment design would be similar for each.In addition, the experiment includes the same requests and parameters for each technology to ensure a fair comparison.\\\subsection{Experiment Evaluation}For the following section we will discuss the main findings from our experiment explained in the section above.\\\begin{figure}[H]    \centering    \hspace*{-2cm}\includegraphics[scale=0.4]{figs/results}    \caption{ Result overview of Neo4j/Redis experiment.}    \label{fig:results}\end{figure}\noindent\textbf{H1 - As Redis stores data through key-value pairs and Neo4j stores data in graphs,    Redis is faster in terms of adding and retrieving data}\\After conducting the experiment for Neo4j and Redis,JMeter provided us with a general statistic table which can be seen in Figure~\ref{fig:results}.The results from the table included several different metrics.An interesting metric to look at is the average response time, which indicates how fast a request could be satisfied by the server.From the results, it is clear that Redis outperforms Neo4j in that metric by a significant margin with a difference of 6.77 ms.Redis with an average of 2.64 ms, and Neo4j with 9.41 ms.Furthermore, another metric that piqued our interest was the Max-metric where Neo4j has its highest response time at 87 ms,whilst Redis has its highest peak at 55 ms.To our knowledge, the high peaks are caused by the sets of initial requests,which have the responsibility to establish a connection with the application.\\Observe that POST requests take longer time to process than GET requests for both technologies.From our understanding, this can be due to the fact that creating objects requires additional business logic and validations.\\Other metrics such as Throughput and Network are not relevant metrics for our evaluation,as they are not directly affected by the chosen technologies.After all, both technologies perform the same simulated load test with the same parameters.Hence, Throughput and Network gives similar results for Neo4j and Redis.\\A factor that might explain why Neo4j has a higher response time than Redis could be their difference in architecture.Storing data in a key-value data structure could be less computationally expensive than constructing a graph to represent the data.\\The highlighted observations support the first hypothesis that Redis is quicker than Neo4j both in terms of adding and retrieving data to the cache.Therefore, we have reasons to accept our first hypothesis, as the results support this claim.\\\noindent\textbf{H2 - In terms of usability and complexity, Redis is simpler to implement than Neo4j }\\When it comes to the setup, Redis was easier and more understandable compared to Neo4j.In both technologies, we struggled with integrating it to our application.We expected that it would be easier to work with Jedis (Java Redis), as we had some prior experience.However, we faced challenges with integrating it to our application.In retrospect, this negative experience should not affect the use of Redis as a cache, because we realized that most of the issues stem from our existing code.Navigating through the official documentation to look at what functionalities Redis offers was a bit challenging.Although the official documentation was structured in a well-organized manner, it still took some time to find what we were after.\\As for Neo4j, we encountered similar issues with the implementation.After struggling to properly integrate it in our code, two issues were found when we simulated the load test.\\Firstly, due to the nature of NoSQL being schemaless, it enabled the possibility for multiple nodes having the same ID.Because of our lack of knowledge and experience working with Neo4j, we were confused as to why our unique ID constraint were not enforced in the database.This resulted in our load tests failing at multiple instances, making us unsure where the core issue actually was.To resolve this issue we had to manually add the constraint for unique ID to the Neo4j database.\\Secondly, Spring Boot’s Neo4j repository did not function as we expected it to do.From our understanding, we suspect it was because the data types from the database would not map properly to the appropriate Java types.Since our experience with Spring Boot repositories have been working consistently without any problems, we did not suspect that the culprit for the issue was the Neo4j repository itself.Our solution was to create a custom service class, and use the Neo4jClient application to manually bind the return value to our desired Java type.\\Overall, both Redis and Neo4j had the same struggles with integrating to our code base.However, we spent much more time implementing Neo4j compared to Redis, due to our inexperience with Neo4j.In addition, by comparing lines of code, Neo4j required more than Redis.To conclude, we accept the hypothesis that Redis is simpler than Neo4j, both in terms of usability and complexity.\\\noindent\textbf{Limitations}\\Nevertheless, it is important to report significant limitations to our experiment.Firstly, our implementation of Neo4j as a cache did not support time to live (TTL).Neo4j by default does not support any direct TTL functionality unlike Redis.A possible solution would be to create a special query that would clear up stale data given a timestamp.This would require our application to have an internal clock that would execute this query periodically.However, in our application, we were unsuccessful with creating such a solution.Without a way to automatically clear stale data, it hinders the efficiency of using Neo4j as a cache.In other words, Neo4j is more suitable as a long term persistent storage, which defeats the purpose of what a cache represents.\\Secondly, our implementation of Redis is using in-memory storage instead of disk like Neo4j.This gives an unfair advantage to Redis, because reading from in-memory will always be faster than disk reading.There was an effort in trying to accomplish persistence mode in Redis, but due to time constraint and lack of knowledge,we were unable to properly integrate disk storing.Therefore, these results may not be an accurate representation of how well Neo4j would perform as a cache in comparison with Redis.However, we believe that the results would be the same even if Redis was using disk storage instead of in-memory storage.As mentioned earlier, this can be because of the architecture of Redis compared to Neo4j.Based on the results of our two hypotheses, we conclude that Redis is more suitable as a cache than Neo4j.\\