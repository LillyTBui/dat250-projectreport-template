\section{Technology Assessment}\label{sec:technology}In this section, the feature technology of the project will be presented and compared to another technology in the context of caching.As mentioned in the introduction, the chosen feature technology is Neo4j which will replace Redis.These technologies are different types of NoSQL databases which are optimized for certain use cases.Redis is a hybrid database and caching system which stores data as key-value pairs in-memory.This makes it a common choice for caching.On the other hand, Neo4j is a graph-based database which stores data in nodes and relationships.Therefore, this paper will explore and compare their capabilities in terms of caching ability by following the evaluation framework from \cite{brown:96}, see Figure~\ref{fig:framework}.This part and other parts of the report probably needs to refer tofigures. Figure~\ref{fig:framework} from \cite{brown:96} justillustrates how figure can be included in the report.\begin{figure}[thb]    \centering    \includegraphics[scale=0.5]{figs/framework.png}    \caption{Software technology evaluation framework.}    \label{fig:framework}\end{figure}\subsection{Descriptive Modeling}To get a better understanding of Neo4j and Redis,their genealogy is illustrated in Figure~\ref{fig:genealogy}.The genealogy shows that Neo4j and Redis are different types of NoSQL databases.In particular, Neo4j is a graph database where entities are represented as nodes,and relationships between entities are represented as edges.Graph databases have existed for a long time, but have not been commercially used until the mid-to-late 2000s [wiki-graph database].During this time the first version of Neo4j was released in February 2010 and has since been gaining popularity [wiki-neo4j].As of November 2025, Neo4j is the most popular graph database according to DB-Engines. ??Similar to other types of graph databases, Neo4j uses its own query language called Cypher.Cypher constructs are declarative, and have similar clauses found in SQL. [?]The advantage of using graph databases is clear when it comes to storing complex relationships,as these actions can be handled directly.\\\begin{figure}[H]    \centering    \includegraphics[scale=0.5]{figs/genealogy.png}    \caption{Neo4j/Redis genealogy.}    \label{fig:genealogy}\end{figure}Additionally, looking up relationships can be computationally expensive in certain scenarios [?].This is because the join queries in relational databases can grow complex and nested as the relationships get advanced.Thus, storing data relationships directly is beneficial in scenarios such as network management system,recommendation system and fraud detection.In those scenarios, having a quick and efficient traversal between data relationships is beneficial.Hence, graph databases are ideal for projects focused on the relationship between data rather than the data itself. [?]Since graph databases do not use a predefined schema, they are highly flexible.Other graph based databases which share similar functionalities as Neo4j are shown as “peers” in Figure~\ref{fig:genealogy}.\\On the other hand, Redis is both a NoSQL database and a hybrid/cache database which makes it suitable for a variety of different use cases.For instance, the most common use case of Redis is to use it as a cache.However, it is possible to use Redis for durable storage (\href{https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/}{https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/}).Redis was created in 2009 and the motivation was to fix the poor scalability in the founder’s startup.Redis has seen massive growth since its release, achieving their record growth in 2025 [wiki-redis].Similarly to its “peers”, Memcached, Riak and Etcd, Redis stores data as key-value pairs.\\An alternative way of showcasing the use cases and competitors of Redis and Neo4j, is the problem domain habitat in Figure~\ref{fig:habitat}.\begin{figure}[thb]    \centering    \includegraphics[scale=0.5]{figs/habitat.png}    \caption{Elements of the Neo4j/Redis habitat.}    \label{fig:habitat}\end{figure}This figure illustrates the technologies, their respective competitors and the problem context.A problem context is a class of problems addressed by the technology. \cite{brown:96}hilst, the special characteristic represents the technology’s ability to solve the problem context.\subsection{Experiment Design}In this section, we will plan how we will evaluate and compare the technologies,where the overall goal is to evaluate how different choices of technology can affect the caching ability.The purpose of caching is to improve performance by storing data in a temporary storage,effectively reducing the need for retrieving data from a permanent database (https://aws.amazon.com/caching/).Therefore, it is particularly interesting to compare two NoSQL databases as they have different ways of storing data due to their underlying architecture and structure.\\In order to effectively evaluate these technologies in the predefined context,the following hypotheses have been made:\begin{enumerate}    \item As Redis stores data through key-value pairs and Neo4j stores data in graphs, Redis is faster in terms of data retrieval.\end{enumerate}Based on the results of the mentioned hypotheses above, the last hypothesis is:\begin{enumerate}    \item[2.] In terms of usability and complexity, Redis is simpler to implement than Neo4j.\end{enumerate}The paper tries to answer these hypotheses by conducting an experiment which is a simplified version of the final project.In order to do so, a branch was made for each technology based on the main branch.Then each technology was implemented in a way that serves as a caching service for the main application.This is to get a better understanding of its overall fit with the existing technology stack.\\The experiment can be divided into two parts.First, simulated users will vote on a specific poll where each vote will be stored according to the chosen technology.Then, handlers will retrieve all votes which triggers the caching logic.In this part of the experiment, we can verify that the correct number of votes are saved to the cache.Furthermore, we can confirm that the data is retrieved from the cache and not the permanent database in the correct setting.\\To ensure consistency in both parts of the experiment, it was decided to use JMeter as the tool to perform a load test.This experiment would help refute or support the proposed hypotheses.Since the first hypothesis is related to data retrieval, the total number of simulated users is 1000.It is important to note that this single experiment will address all of the hypotheses, as the setup and experiment design would be similar for each.In addition, the experiment includes the same requests and parameters for each technology to ensure a fair comparison.\\\subsection{Experiment Evaluation}Write about the results of your experiments, either via personal experience reports, quantitative benchmarks, a demostrator case study or a combination of multiple approaches.For some reports you may have to include a table with experimentalresults are other kinds of tables that for instance comparestechnologies. Table~\ref{tab:results} gives an example of how to create a table.\begin{table}[bth]	\centering	\begin{tabular}{llrrrrrr}		Config & Property & States & Edges & Peak & E-Time & C-Time & T-Time		\\ \hline \hline		22-2 & A   &    7,944  &   22,419  &  6.6  \%  &  7 ms & 42.9\% &  485.7\% \\		22-2 & A   &    7,944  &   22,419  &  6.6  \%  &  7 ms & 42.9\% &  471.4\% \\		30-2 & B   &   14,672  &   41,611  &  4.9  \%  & 14 ms & 42.9\% &  464.3\% \\		30-2 & C   &   14,672  &   41,611  &  4.9  \%  & 15 ms & 40.0\% &  420.0\% \\ \hline		10-3 & D   &   24,052  &   98,671  & 19.8  \%  & 35 ms & 31.4\% &  285.7\% \\		10-3 & E   &   24,052  &   98,671  & 19.8  \%  & 35 ms & 34.3\% &  308.6\% \\		\hline \hline	\end{tabular}	\caption{Selected experimental results on the communication protocol example.}	\label{tab:results}\end{table}